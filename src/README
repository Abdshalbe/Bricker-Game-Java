tomerelal
208244244

Explanations of classes:

class ChangeCameraStrategy - This class describes a strategy of moving a camera according to the game ball.
This class inherits from the parent class of Standard Brick Break Strategy.

class DoubleStrategy - This class describes a strategy of activating two - three special strategies when
breaking a brick. This class inherits from the parent class of Standard Brick Break Strategy.

class ExtraBallsStrategy - This class describes a strategy of adding some number of extra balls when
breaking a brick. This class inherits from the parent class of Standard Brick Break Strategy.

class ExtraLifeStrategy - This class describes a strategy of dropping extra lives when breaking a brick.
This class inherits from the parent class of Standard Brick Break Strategy.

class ExtraPaddleStrategy - This class describes a strategy of adding one paddle to the game (at most one)
when breaking a brick. This class inherits from the parent class of Standard Brick Break Strategy.

class CollisionStrategiesFactory - This class job is to produce special brick collision strategies

class ExtraLife - This class inherits from the graphic heart object class. The role of the class is
to represent an extra life object that falls from a brick during the game

class ExtraPaddle - This class inherits from the player's regular paddle class.
it's role is to represent Extra Paddle in the game

***** In the ball department I added a function that records the number of collisions of any ball and I also
added the field in which we will update the number of collisions at any given moment. The reason I added this
functionality to the ball class is that the camera strategy needs to know how many collisions the ball has
made and accordingly stop the camera tracking the ball. *****


Answering the questions in the exercise file:

I will go ahead and say that the solution I chose is that each brick will contain a collision strategy of a
parent class which is the normal collision, then the special collisions are inherited from the normal
collision class so that the brick can also contain special strategies, which means polymorphism exists here.


1) The special game strategy classes that we were asked to implement, in my program, they inherit from the
   standard collision strategy class in which the brick simply breaks and disappears from the screen.
   The reason is that every special strategy is a type of normal strategy. Since each special strategy in
   particular also breaks the brick upon collision and also the brick has to disappear from the game,
   here also comes the matter of a code that is reinforced on itself in all the special strategies,
   therefore I considered it appropriate that this code be a common code found in the parent class.
   Also, during the writing of the program, I had to add the class that represents an Extra Life object that
   inherits from the ball object class. The reason is that first of all extra life is a type of 'normal' life
   and it was necessary to define differently the collision of the extra life object with other objects.
   In addition, it was necessary to override the function that updates the additional heart object in each
   frame. In the same way, it was also necessary to create a class that inherits from the player's paddle,
   which is the extra paddle class. The reason is that the functionality in the Extra Paddle is different from
   that of the player, for example that after the number of hits the Extra Paddle should disappear. Also, as
   mentioned, the extra paddle is a type of normal paddle, so it is appropriate to have a successor class here

2) As I explained earlier the reason I chose inheritance is that all the special strategies are types of
   normal brick breaking strategy. Beyond that, it allows polymorphism in the code since the brick object
   receives a general collision strategy in its constructor, which means that only at runtime it is known
   which strategy exactly the brick receives.
   In fact, it was possible to choose an interface as well and thus achieve the same result of polymorphism,
   but I preferred to use inheritance because code is common to all special strategies and as I said they are
   types of normal strategy.

3) My limit on the amount of dual behaviors is simply accepted as an argument to the dual strategy class.
   In practice - the realization of the class of the dual strategy is in such a way that the class receives
   some set of special strategies and the class has functionality that when it collides with a brick that
   contains this strategy, a number of special strategies will be activated in accordance with the argument
   that limits the number of special strategies that can be drawn and according to the draw. The limitation of
   the number of strategies is realized in my code using recursion when the base case is that the brick
   already contains the number of strategies I received in the argument in the constructor of the double
   strategy class.

4) The strategy I chose for a brick to have more than one behavior is that the double strategy is implemented
   by a class that inherits from the normal collision strategy class. In this way if a brick receives a double
   behavior strategy then the double behavior class will be responsible for generating more strategies on that
   brick. This solution supports the extension of the behavior number to the brick in that all one needs to do
   is to change the number that is sent as an argument to the constructor of the double strategy. If we send 3
   then the brick with double behavior will have at most 3 special strategies
   (not including the normal and double) and if we send 100 then the brick will have at most 100
   special strategies. Moreover, if we want to add another type of strategy in the future,
   all we have to do is add its instance in the parameter of the list of strategies that we
   send to the double strategy constructor.













